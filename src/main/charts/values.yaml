# Default values for api.

# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

environment: dev
basefqdn: private.test.example.com
# The path  the microservice is eposed to the exterior
# If not present, it defaults to the  name of the ms.
# basePath: /

# Extra hosts for
hosts: []
#- "template.private.test.example.com"

## Grafana dashboard configuration

grafana:
  folder: ""
  dashboards: []

    # The grafana folder to place the dashboards in
  # Not working yet.


## Kubernetes specific configuration
k8s:
  # Labels and annotations to add in all resources
  extraLabels:
    tier: backend
  extraAnnotations: {}
  ## Deployment configuration
  deployment:
    enabled: true
    image:
      repository: pjgg/code-with-quarkus
      tag: latest
      pullPolicy: IfNotPresent

    # Allow configuring cmd and args
    # command: []
    # args: []
    replicaCount: 1
    ## Set resources limits and requests
    ## always set, if empty you might face resource devastation
    resources:
      limits:
        cpu: 300m
        memory: 100Mi
      requests:
        cpu: 20m
        memory: 20Mi
    lifecycle: {}
    ## Kubernetes liveness probe
    ## configure to configure liveness
    enableLiveness: true
    livenessProbe:
      initialDelaySeconds: 30
      periodSeconds: 10
      timeoutSeconds: 3
      failureThreshold: 3
      successThreshold: 1
      httpGet:
        httpHeaders:
          - name: customer-session-id
            value: k8s-liveness-probe
        path: /health/live
        port: 8080
    ## Specifies the strategy used to replace old Pods by new ones
    ## Ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/
    strategy:
      type: RollingUpdate
      ## Specifies the maximum number of Pods that can be created over the desired number of Pods
      ## The value cannot be 0 if MaxUnavailable is 0.
      maxSurge: "25%"
      ## Specifies the maximum number of Pods that can be unavailable during the update process
      maxUnavailable: "25%"

    ## Kubernetes will send traffic when readiness passes
    enableReadiness: true
    readinessProbe:
      initialDelaySeconds: 10
      periodSeconds: 5
      timeoutSeconds: 3
      failureThreshold: 1
      successThreshold: 1
      httpGet:
        httpHeaders:
          - name: customer-session-id
            value: k8s-liveness-probe
        path: /health/ready
        port: 8080

    ## hostAliases allow appending values to the /etc/hosts of the pod
    hostAliases: []
    # - ip: "127.0.0.1"
    #   hostnames:
    #   - "example.org"
    # - ip: "192.168.0.1"
    #   hostnames:
    #   - "micasa"
    #   - "telefono"

    ## Node tolerations for scheduling to nodes with taints
    ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
    ##
    tolerations: []

    ## Node labels for pod assignment
    ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
    ##
    nodeSelector: {}

    environment:
      extraVars: []
      # - name: GOOGLE_APPLICATION_CREDENTIALS
      #   value: "/etc/secrets/google/key.json"
      # - name: AUTH_TOKEN
      #   valueFrom:
      #     secretKeyRef:
      #       key: token
      #       name: auth-secrets
      extraVarsObject: {}
        # GOOGLE_APPLICATION_CREDENTIALS:
        #   value: "/etc/secrets/google/key.json"
        # AUTH_TOKEN:
        #   valueFrom:
        #     secretKeyRef:
        #       key: token
      #       name: auth-secrets

      renderVars: []
      # - name: SENTRY_RELEASE
      #   value: "{{ .Release.Name  }}-{{ .Values.k8s.deployment.image.tag }}"

    # Ports that do not exist in the service but are still needed.
    # The names will be rendered as "<name>" and truncated to 15 chars
    # It is mandatory for the name to adhere to istio convections
    # https://istio.io/docs/setup/kubernetes/additional-setup/requirements/
    extraPorts: []
      # - name: http-prom
      #   protocol: TCP
    #   port: 8080

    # Wether the deployment should be assigned a service account
    serviceAccount:
      # Wether to create the service account
      create: false
      # If create is true and  no name is provided, template 'base.name' will be used.
      # If create is false, you should create sa with this name (empty for no serviceAccount)
      name: ""
      # Annotations to add to the service account
      annotations: {}
      #  iam.gke.io/gcp-service-account: "mysquad@mm-k8s-dev-01.iam.gserviceaccount.com"
    # Use some security context in container level
    #securityContextContainer:
    #  privileged: true
    #  capabilities:
    #    add:
    #    - SYS_ADMIN
    # Kubernetes service
    # The names will be rendered as "<name>-<namespace>"

    # List of created secrets in the same namespace to be mounted on the deployment
    externalSecrets:
    # # Name of the secret
    # - name:
    # # Path to be mouted
    #   mountPath:
    # # If present, only this subpath will be mounted
    #   subPath:

  service:
    enabled: true
    name: http
    type: ClusterIP
    # Service LoadBalancer Type
    # If the loadBalancerIP field is not specified, the loadBalancer is set up with an ephemeral IP address.
    # loadBalancerIP: X.X.X.X
    externalPort: 80
    internalPort: 8080
    protocol: TCP
    extraPorts: []
    # - name: http-prom
    #   externalPort: 9090
    #   internalPort: 9091
    #   protocol: TCP
    annotations: {}
      # prometheus.io/probe: "true"
      # prometheus.io/path: "/metrics"
    # prometheus.io/port: "9091"

  # External Names
  # Allows creation of externalName services needed for the chart.
  # For example, the ip of a redis master
  externalnames: []
  # - name: redis
  #   address: 127.0.0.1
  persistentVolume:
    ## If true, deployment will create/use a Persistent Volume Claim
    ## If false, use emptyDir
    ##
    enabled: false

    ## deployment data Persistent Volume access modes
    ## Must match those of existing PV or dynamic provisioner
    ## Ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
    ##
    accessModes: ReadWriteOnce

    ## deployment data Persistent Volume Claim annotations
    ##
    annotations: {}

    ## deployment data Persistent Volume existing claim name
    ## Requires k8s.deployment.persistentVolume.enabled: true
    ## If defined, PVC must be created manually before volume will be bound
    existingClaim: ""

    ## deployment data Persistent Volume mount root path
    ##
    mountPath: /data

    ## deployment data Persistent Volume size
    ##
    size: 2Gi

    ## deployment data Persistent Volume Storage Class
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
    ##   GKE, AWS & OpenStack)
    ##
    # Class: "-"

    ## Subdirectory of deployment data Persistent Volume to mount
    ## Useful if the volume's root directory is not empty
    ##
    subPath: ""

  # Kubernetes Horizontal Pod Autoscaler
  hpa:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 60

  # Kubernetes POD Disruption budget
  disruptionbudget:
    enabled: true
    minAvailable: 1

  # K8s secrets to create (as array)
  # This should be handled with helm secrets
  secrets: []
  # - name: db-credentials
  #   data:
  #     user: "base64-stuff"
  #     password: "morebase64-stuff"
  # - name: gcp-service-account
  #   mountPath: /etc/secrets/google
  #   data:
  #     "key.json": "base64-slug"

  # K8s secrets to create (as object)
  # This should be handled with helm secrets
  secretFiles: {}
    # db-credentials:
    #   data:
    #     user: "base64-stuff"
    #     password: "morebase64-stuff"
    # gcp-service-account:
    #   mountPath: /etc/secrets/google
    #   data:
  #     "key.json": "base64-slug"

  monitoring:
    serviceMonitor:
      enabled: false
      endpoints: []
      # - port: http-prom
      #   path: /metrics
    prometheus:
      enabled: false
      name: "prometheus-{{ .Release.Namespace }}"
      rules: {}
      #  groups:
      #  - name: kubernetes-apps
      #    rules:
      #    - alert: KubePodCrashLooping
      #      annotations:
      #        message: Pod {{ $labels.namespace }}/{{ $labels.pod }} ({{ $labels.container }}) is restarting {{ printf "%.2f" $value }} times / 5 minutes.
      #        runbook_url: https://github.com/kubernetes-monitoring/kubernetes-mixin/tree/master/runbook.md#alert-name-kubepodcrashlooping
      #      expr: rate(kube_pod_container_status_restarts_total{job="kube-state-metrics"}[15m]) * 60 * 5 > 0
      #      for: 15m
      #      labels:
      #        severity: critical

# Where config.yaml is mounted to
config:
  configPath: /etc/config
  configFile: config.yaml
  # One of yaml or json
  configFormat: yaml
  envvar: CONFIG_PATH
# Application specific config must be set here only
# Whatever is under here, will be mounted as a configmap in the pod.
app: {}
  # # This value is the name of your application. Is used to separate Stackdriver
  # # data from other projects.
  # name: go-template

  # # This value is the version of your application. It will be displayed in the CLI
  # # and will be used to tell the difference between different versions of this
  # # application in Stackdriver.
  # version: 0.1.0

  # # The environment defines where the application is being runned. It could be
  # # LOCAL, STAGING or PRODUCTION.
  # environment: LOCAL

  # # The level of log that will be printed.
  # logLevel: debug

  # # This is the sentry error reporter configuration.
  # sentry:
  #   enabled: true
  #   dsn: https://dsn:example@sentry.example.com/123

  # # This is the API HTTP server related configuration.
  # server:
  #   # The address and the port where the HTTP server will be listening.
  #   address: 0.0.0.0:8080
  #   # This value will be placed in the URIs of the application endpoints.
  #   context: go-template

  # # This is the configuration related to Prometheus.
  # prometheus:
  #   # The address and the port where the HTTP server used by prometheus will be listening.
  #   address: 0.0.0.0:8082

  # # GCloud services configuration
  # gcloud:
  #   # The project where things things like profiling and tracing data will live.
  #   # Other services as Datastore can live in other projects as long as the
  #   # service account used by this microservice has access to it.
  #   projectID: microservice-project

  #   # Path of the Google Cloud service account Key file.
  #   credentialsPath: /etc/config/keyfile.json

  #   # GCloud Stackdriver Profiler configuration.
  #   profiler:
  #     enabled: false
  #     noHeapProfiling: false
  #     noAllocProfiling: false
  #     noGoroutineProfiling: false
  #     debugLogging: false
  #     mutexProfiling: false

  #   # GCloud Stackdriver Trace configuration.
  #   trace:
#     enabled: false

# Extra files for the configmap
extraconfig: {}
  # "log.template": |
  #   "logline": "immakingthisup"
  #   "logformat": "json"
  # "moreconfig.yaml": |
  #   othervalue:
#     inside: "extra config options"